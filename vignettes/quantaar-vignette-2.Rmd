---
title: "Surface kriging and object attribution for small scale excavations"
author: "Clemens Schmid"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Spit attribution for small scale excavations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE}
if (!requireNamespace("plotly", quietly = TRUE)) {
  stop("plotly needed for this vignette to build.",
    call. = FALSE)
}
```

First we need to load quantaar and some external packages:

- **dplyr**: filter function
- **kriging**: simple surface modelling tool
- **magrittr**: introduces piping to R via %>% operator
- **plotly**: nice, interactive plots via javascript implementation

```{r, message=FALSE}
devtools::load_all()
library(dplyr)
library(kriging)
library(magrittr)
library(plotly)
```

Now let's imagine an artificial and pretty simple excavation trench with a depth of 2 meters, a length of 3 meters and a width of 1 meter. 

```{r}
edges <- data.frame(
  x = c(0, 3, 0, 3, 0, 3, 0, 3),
  y = c(0, 0, 0, 0, 1, 1, 1, 1),
  z = c(0, 0, 2, 2, 0, 0, 2, 2)
)
```

We can plot the corner points of this trench:

```{r fig.width=7, fig.height=5}
vis <- plot_ly(edges, x = x, y = y, z = z, type = "scatter3d", mode = "markers"
  ) %>% 
  layout(
    showlegend = FALSE,
    autorange = F, 
    aspectmode = 'manual', 
    scene = list(
      dragmode = "orbit",
      aspectratio = list(x=3, y=1, z=3),
      camera = list(
        eye = list(x = 4, y = 4, z = 1) 
      )
    )
  )

vis
```

When we look at the profiles of our fictional trench we can trace three clearly separated horizons following the natural slope. Let's figuratively take some measurements of the two horizon borders by creating two data.frames with points along the profiles. The z-axis values are randomly computed.  

```{r}
df1 <- data.frame(
  x = c(rep(0, 6), seq(0.2, 2.8, 0.2), seq(0.2, 2.8, 0.2), rep(3,6)),
  y = c(seq(0, 1, 0.2), rep(0, 14), rep(1, 14), seq(0, 1, 0.2)), 
  z = c(0.9+0.05*rnorm(6), 0.9+0.05*rnorm(14), 1.3+0.05*rnorm(14), 1.2+0.05*rnorm(6))
)

df2 <- data.frame(
  x = c(rep(0, 6), seq(0.2, 2.8, 0.2), seq(0.2, 2.8, 0.2), rep(3,6)),
  y = c(seq(0, 1, 0.2), rep(0, 14), rep(1, 14), seq(0, 1, 0.2)),
  z = c(0.6+0.05*rnorm(6), 0.6+0.05*rnorm(14), 1.0+0.05*rnorm(14), 0.9+0.05*rnorm(6))
)
```

Looks complicated? Becomes pretty simple, when we look at a plot:

```{r fig.width=7, fig.height=5}
vis <- vis %>%
  add_trace(data = df1, x = x, y = y, z = z, 
            mode = "markers", type = "scatter3d", 
            marker = list(size = 4, color = "green", symbol = 104)
  ) %>%
  add_trace(data = df2, x = x, y = y, z = z, 
            mode = "markers", type = "scatter3d", 
            marker = list(size = 4, color = "blue", symbol = 104)
  ) 

vis
```

We can put this two or even more data.frames with observations into a list and feed it to `quantaar::kriglist`. This function serves as an interface to `kriging::kriging`. We'll get a list list of data.frames with surface estimations for the two input layers. 

```{r }
lpoints <- list(df1, df2)

maps <- kriglist(lpoints, lags = 3, model = "spherical")
```

The result of `kriging::kriging` is in a tall format -- we have to transform it. For this purpose we use `quantaar::spatialwide`.

```{r}
surf1 <- spatialwide(maps[[1]]$x, maps[[1]]$y, maps[[1]]$pred, 3)
surf2 <- spatialwide(maps[[2]]$x, maps[[2]]$y, maps[[2]]$pred, 3)

x1 <- as.numeric(colnames(surf1))
y1 <- as.numeric(rownames(surf1))
z1 <- as.matrix(surf1)
x2 <- as.numeric(colnames(surf2))
y2 <- as.numeric(rownames(surf2))
z2 <- as.matrix(surf2)
```

After the transformation we can visualize the generated surfaces:

```{r fig.width=7, fig.height=5}
vis <- vis %>% 
  add_trace(x = x1, y = x1, z = z1, type = "surface", showscale = FALSE
  ) %>%
  add_trace(x = x2, y = x2, z = z2, type = "surface", showscale = FALSE
  ) 

vis
```

During the excavation we separated the finds of many artificial spits (each 1m\*1m\*0.2m). Let's enter the corner coordinates for one:

```{r fig.width=7, fig.height=5}
hexatestdf <- data.frame(
  x = c(1, 1, 1, 1, 2, 2, 2, 2),
  y = c(0, 1, 0, 1, 0, 1, 0, 1),
  z = c(0.8, 0.8, 1, 1, 0.8, 0.8, 1, 1)
)
```

Now we can fill the shape with an equidistant three dimensional point raster using `quantaar::fillhexa` and take a look at it.

```{r}
cx = fillhexa(hexatestdf, 0.05)
```

```{r fig.width=7, fig.height=5}
vis %>% 
  add_trace(data = cx, x = x, y = y, z = z, 
            mode = "markers", type = "scatter3d", 
            marker = list(size = 1, color = "red", symbol = 104)
  )
```

Damn! This spit penetrates both reconstructed surfaces. We should try to determine how his volume is distributed among the three major horizons of our trench. For this purpose we apply `quantaar::posdeclist`. It makes a position decision for every point of the artificial point raster we created with `quantaar::fillhexa`.

```{r fig.width=7, fig.height=5}
cuberasterlist <- list(cx)

crlist <- posdeclist(cuberasterlist, maps)

hexa <- crlist[[1]]

a <- filter(
  hexa,
  pos == 0
)

b <- filter(
  hexa,
  pos == 1
)

c <- filter(
  hexa,
  pos == 2
)

vis %>% add_trace(data = a, x = x, y = y, z = z, 
            mode = "markers", type = "scatter3d", 
            marker = list(size = 1, color = "#31a354", symbol = 104)
  ) %>% add_trace(data = b, x = x, y = y, z = z, 
            mode = "markers", type = "scatter3d", 
            marker = list(size = 1, color = "#de2d26", symbol = 104)
  ) %>% add_trace(data = c, x = x, y = y, z = z, 
            mode = "markers", type = "scatter3d", 
            marker = list(size = 1, color = "#2b8cbe", symbol = 104)
  )
```

Finally we can find out the percentual distribution. Could be an interesting information to determine the possible origin of finds from this spit.

```{r}
# deci: create a result data.frame which shows the distribution of cube points
deci <- function (crlist) {
  
  # determine amount of layers
  nl = max(unlist(lapply(crlist, function(x) max(x$pos, na.rm=T))))
  # create result data.frame
  m <- matrix(NA, ncol = nl+1, nrow = 1)
  pos <- data.frame(m)
  names(pos) <- c(0:nl)
  # calculate distribution
  for (crp in 1:length(crlist)) {
    cr <- crlist[[crp]]
    crd <- sort(unique(cr$pos))
    ncr <- nrow(cr)
    for (i in 1:length(crd)) {
      pos[crp, names(pos) == crd[i]] <- nrow(filter(cr, pos == crd[i]))/ncr*100
    }
  }
  return(pos)
}

deci(crlist)
```