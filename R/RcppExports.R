# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Fills hexahedrons with a systematic point raster
#'
#' See \url{https://stackoverflow.com/questions/36115215/filling-a-3d-body-with-a-systematic-point-raster}
#' for a description of the function and how it was developed.
#'
#' @param hex dataframe with three columns and eight rows to define a hexahedron by its corner
#' point coordinates
#' @param res numeric value > 0 and <= 1 for the resolution of the point raster
#'
#' @return data.frame with the spatial coordinates of the resulting points of the filling raster
#'
#' @examples
#' hexatestdf <- data.frame(
#'   x = c(0,1,0,4,5,5,5,5),
#'   y = c(1,1,4,4,1,1,4,4),
#'   z = c(4,8,4,9,4,8,4,6)
#' )
#'
#' cx = fillhexa(hexatestdf, 0.1)
#'
#' #library(rgl)
#' #plot3d(
#' # cx[,1], cx[,2], cx[,3],
#' # type = "p",
#' # xlab = "x", ylab = "y", zlab = "z"
#' #)
#'
#' @export
fillhexa <- function(hex, res) {
    .Call('quantaar_fillhexa', PACKAGE = 'quantaar', hex, res)
}

#' position decision in relation to a set of stacked surfaces
#'
#' \code{posdec} has the purpose to make a decision about the position of individual points in relation
#' to a set of stacked surfaces. The decision is made by comparing the mean z-axis value of the four
#' horizontally closest points of a surface to the z-axis value of the point in question.
#'
#' @param crlist data.frame with the spatial coordinates of the points of interest
#' @param maplist list of data.frames which contain the points that make up the surfaces
#'
#' @return data.frame with the spatial coordinates of the points of interest and the respective position
#' information
#'
#' @examples
#' df1 <- data.frame(
#'   x = rnorm(50),
#'   y = rnorm(50),
#'   z = rnorm(50) - 5
#' )
#'
#' df2 <- data.frame(
#'   x = rnorm(50),
#'   y = rnorm(50),
#'   z = rnorm(50) + 5
#')
#'
#' lpoints <- list(df1, df2)
#'
#' maps <- kriglist(lpoints, lags = 3, model = "spherical")
#'
#' finds <- data.frame(
#'   x = c(0, 1, 0.5, 0.7),
#'   y = c(0.5, 0, 1, 0.7),
#'   z = c(-10, 10, 0, 2)
#' )
#'
#' posdec(finds, maps)
#'
#' @export
posdec <- function(crlist, maplist) {
    .Call('quantaar_posdec', PACKAGE = 'quantaar', crlist, maplist)
}

#' position decision in relation to a set of stacked surfaces (for lists of data.frames)
#'
#' \code{posdeclist} works as \code{posdec} but not just for a single data.frame but for a list of
#' data.frames
#'
#' @param crlist list of data.frames with the spatial coordinates of the points of interest
#' @param maplist list of data.frames which contain the points that make up the surfaces
#'
#' @return list of data.frames with the spatial coordinates of the points of interest and the respective
#' position information
#'
#' @examples
#' df1 <- data.frame(
#'   x = rnorm(50),
#'   y = rnorm(50),
#'   z = rnorm(50) - 5
#' )
#'
#' df2 <- data.frame(
#'   x = rnorm(50),
#'   y = rnorm(50),
#'   z = rnorm(50) + 5
#')
#'
#' lpoints <- list(df1, df2)
#'
#' maps <- kriglist(lpoints, lags = 3, model = "spherical")
#'
#' hexadf1 <- data.frame(
#'   x = c(0, 1, 0, 4, 5, 5, 5, 5),
#'   y = c(1, 1, 4, 4, 1, 1, 4, 4),
#'   z = c(1, 5, 1, 6, 1, 5, 1, 3)
#' )
#'
#' hexadf2 <- data.frame(
#'   x = c(0, 1, 0, 4, 5, 5, 5, 5),
#'   y = c(1, 1, 4, 4, 1, 1, 4, 4),
#'   z = c(-1, -5, -1, -6, -1, -5, -1, -3)
#' )
#'
#' cx1 <- fillhexa(hexadf1, 0.1)
#' cx2 <- fillhexa(hexadf2, 0.1)
#'
#' cubelist <- list(cx1, cx2)
#'
#' posdeclist(cubelist, maps)
#'
#' @export
posdeclist <- function(crlist, maplist) {
    .Call('quantaar_posdeclist', PACKAGE = 'quantaar', crlist, maplist)
}

